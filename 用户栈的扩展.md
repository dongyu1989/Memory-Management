# Memory-Management

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405i.jpg "空间分布")

假设在进程运行的过程中，已经用尽了为本进程分配的堆栈区间，也就是从堆栈的“顶部”开始，已经到达了已映射的堆栈区间的下沿。或者说，CPU中的堆栈指针%esp已经指向堆栈区间的起始地址，如上图。

假定现在需要调用某个子程序，因此CPU需将返回地址压入堆栈，也就是要将返回地址写入虚存空间中地址为(%esp-4)的地方。可是，在我们这个情景中地址(%esp-4)落入了空洞中，这是尚未映射的地址，因此必然要引起一次页面错异常。

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405j.jpg "空间分布")

这一次，空间上方的区间是堆栈区间，其VM_GROWSDOWN标志为1，所以CPU就继续往前执行。当映射失败发生在用户空间(bit2为1)时，因堆栈操作而引起的越界是作为特殊情况对待的，所以还需要检查发生异常时的地址是否紧挨着堆栈指针所指向的地方。在我们情景中，那个%esp-4,当然是紧挨着。戴氏如果是%esp-40呢，那就不会是因为正常的堆栈操作而引起，而是货真价实的非法越界访问了。可是，怎么来判定“正常”或“不正常”呢，通常，一次压入堆栈是4个字节，所以地址应该是%esp-4。但是i386CPU有一条pusha指令，可以一次将32字节压入堆栈。所以，检查的准则是%esp-32。超出这个范围就一定是错的了。在现在这个情景中，这个测试应是顺利通过的。

既然是属于正常的堆栈扩展要求，那就应该从空洞的顶部开始分配若干页面建立映射，并将之并入堆栈区，使其得以扩展。所以就要求调用expand_stack（）:

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405k.jpg "空间分布")

参数vma指向一个vm_area_struct数据结构，代表着一个区间，在这里就是代表用户空间堆栈所在的区间。首先，将地址按页面边界对齐，并计算需要增长几个页面才能吧给定的地址包括进去。这里还有个问题，堆栈的这种扩展是否不受限制，直到把空间中的整个空洞用完为止呢？不是的，每个进程的个task_struct结构中都有rlim结构数组，规定了对每种资源分配使用的限制，而RLIMIT_STACK就是对用户空间堆栈大小的限制。所以，这里就进行这样的检查。如果扩展以后的区间大小超过了可用于堆栈的资源，或者使用动态分配的页面总量超过了可用于改进程的资源限制，那就不能扩展了，就会返回一个负的出错代码-ENOMEM，表示没有存储空间可以分配了；否则就应该返回0。当expand_stack（）返回值为非0，也即-ENOMEM时，在do_page_fault（）中也会转向bad_area。不过一般情况下都不至于用尽资源，所以expand_stack（）一般都是正常返回的。但是，我们已经看过，expand_stack()只是改变了堆栈区的vm_area_struct结构，而并未建立起新扩展的页面对物理内存的映射，这个任务由接下去的good_area完成。

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170406a.jpg "空间分布")

这里的switch语句中，内核根据由中断响应机制传过来的error_code来进一步确定映射失败原因并采取相应的策略(error_code最低三位的定义前面已给出)。就现在这个情景而言，bit0为0，便是没有物理页，而bit1为1表示写操作。所以，最低两位值为2。既然是写操作，当然要检查相应区间是否允许写入，而堆栈段是允许写入的。于是，就到达196行，调用虚存管理handle_mm_fault（）：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170406b.jpg "空间分布")

根据给定的地址和代表着具体虚存空间的mm_struct数据结构，由宏操作pgd_offset（）计算出指向改地址所述页面目录项的指针。
```c
    #define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD1))
    #define PGDIR_SHIFT 22
    #define PTRS_PER_PGD 1024
```
