# Memory-Management

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405i.jpg "空间分布")

假设在进程运行的过程中，已经用尽了为本进程分配的堆栈区间，也就是从堆栈的“顶部”开始，已经到达了已映射的堆栈区间的下沿。或者说，CPU中的堆栈指针%esp已经指向堆栈区间的起始地址，如上图。

假定现在需要调用某个子程序，因此CPU需将返回地址压入堆栈，也就是要将返回地址写入虚存空间中地址为(%esp-4)的地方。可是，在我们这个情景中地址(%esp-4)落入了空洞中，这是尚未映射的地址，因此必然要引起一次页面错异常。

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405j.jpg "空间分布")

这一次，空间上方的区间是堆栈区间，其VM_GROWSDOWN标志为1，所以CPU就继续往前执行。当映射失败发生在用户空间(bit2为1)时，因堆栈操作而引起的越界是作为特殊情况对待的，所以还需要检查发生异常时的地址是否紧挨着堆栈指针所指向的地方。在我们情景中，那个%esp-4,当然是紧挨着。戴氏如果是%esp-40呢，那就不会是因为正常的堆栈操作而引起，而是货真价实的非法越界访问了。可是，怎么来判定“正常”或“不正常”呢，通常，一次压入堆栈是4个字节，所以地址应该是%esp-4。但是i386CPU有一条pusha指令，可以一次将32字节压入堆栈。所以，检查的准则是%esp-32。超出这个范围就一定是错的了。在现在这个情景中，这个测试应是顺利通过的。

既然是属于正常的堆栈扩展要求，那就应该从空洞的顶部开始分配若干页面建立映射，并将之并入堆栈区，使其得以扩展。所以就要求调用expand_stack（）:

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405k.jpg "空间分布")

