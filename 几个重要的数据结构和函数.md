# Memory-Management

几个重要的数据结构和函数
------------

页面目录PGD，中间目录PMD和页面表PT分别是由表项pgd_t,pmd_t以及pte_t构成的数组，而这些表项又都是数据结构，定义于include/asm-i386/page.h中：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403b.png "数据结构")

可见，当采用32位地址时，pgd_t,pmd_t和pte_t实际上就是长整形，而当采用36位地址时则是long long整数。之所以不直接定义成长整数的原因在于这样可以让gcc在编译时加上更严格的类型检查。同时，代码中又定义几个简单的函数来访问这些结构的成分，如pte_val(),pgd_val()等。但是，表项PTE作为指针实际上需要它的高20位。同时，所有物理页面都是4K字节的边界对齐的，因而物理页面起始地址的高20位可以看做是物理页面的序号。所以，pte_t中的低12位用于页面的状态信息和访问权限。在内核代码并没有在pte_t等结构中定义有关的位段，而是在page.h中另行定义一个用来说明页面保护的结构pgprot_t:

```c
    typedef struct {unsigned long pgport; } pgprot_t;
```
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403c.png "标志位")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403d.png "标志位")

注意这里的PAGE_PROTNONE对应页面表项中的bit7，在intel的手册中说这一项保留不用，所以对MMU不起作用。
在实际使用中，pgprot的数值总是小于0x1000，而pte中的指针部分则总是大于0x1000，将两者合在一起就得到使用用于页面表中的表项。具体的计算是由pgtable.h中定义的宏操作mk_pte完成的：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403e.png "mk_pte")

这里将页面序号左移动12位，再与页面的控制/状态位段相或，就得到了表项的值。这里引用的两个宏操作均定义于include/asm-i386/page.h中：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403f.png "宏操作")

内核中有个全局量mem_map，是一个指针，指向一个page数据结构的数组，每个page数据结构代表着一个物理页面。因此，页面表项的高20位对于软件和MMU硬件有着不同的意义。对于软件，这是个物理页面的序号，将这个序号用作下标就可以从mem_map找到代表这个物理页面的page数据结构。对于硬件，则就是物理页面的起始地址。

还有一个常用的宏操作set_pte(),用来把一个表项的值设置到一个页面表项中，这个宏操作定义于include/asm-i386/pgtable-2level.h中：
```c
   #define set_pte(pteptr, pteval)( *(pteptr) = pteval )
```

在映射的过程中，MMU首先检查的是P标志位，就是上面的PAGE_PRESENT，它指示着所映射的页面是否存在内存中。只有在P标志为1的时候MMU才会完成映射的过程：否则就会因不能完成映射产生一次缺页中断，此时表项中其他内容对MMU就没有任何意义了。除MMU硬件根据页面表项的内容进行页面映射，软件也可以设置或检测页面表项的内容，上面的set_pte()就是用来设置页面表项。内核还未检测页面表项的内容定义了一些工具性的函数或宏操作，其中最重要的有：
```c
   #define pte_none(x) ( !(x).pte_low )
   #define pte_present(x) ( (x).pte_low & (_PAGE_PRESENT | _PAGE_PROTNONE ) )
```

对软件来说，页面表项为0表示尚未为这个表项建立映射，所以还是空白；而如果页面表项不为0，但P标志为0，则表示映射已经建立，但是所映射的物理页面不在内存中。

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403h.png "宏操作")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403g.png "宏操作")

当然，这些标志位只有在P标志为1时才有意义。
当前所述，当页面表项的P标记位为1时，其高20位为相应物理页面起始地址的高20位，由于物理页面的起始地址必然是与页面边界对齐的，所以低12位一定是0。如果把整个物理内存看成一个物理页面的“数组”，那么高20位就是就是数组的下标，也就是物理页面的序号。相应地，用这个下标，就可以在上述的page结构数组中找到代表目标物理页面的数据结构。代码中为此也定义一个宏操作(include/asm-i386/pgtable.h):
```c
    #define pte_page(x) ( mem_map((unsigned long)(((x).pte_low >> PAGE_SHIFT))))
```

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170404a.png "mem_map_t")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170404b.png "mem_map_t")

