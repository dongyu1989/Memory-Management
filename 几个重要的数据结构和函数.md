# Memory-Management

几个重要的数据结构和函数
------------

页面目录PGD，中间目录PMD和页面表PT分别是由表项pgd_t,pmd_t以及pte_t构成的数组，而这些表项又都是数据结构，定义于include/asm-i386/page.h中：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403b.png "数据结构")

可见，当采用32位地址时，pgd_t,pmd_t和pte_t实际上就是长整形，而当采用36位地址时则是long long整数。之所以不直接定义成长整数的原因在于这样可以让gcc在编译时加上更严格的类型检查。同时，代码中又定义几个简单的函数来访问这些结构的成分，如pte_val(),pgd_val()等。但是，表项PTE作为指针实际上需要它的高20位。同时，所有物理页面都是4K字节的边界对齐的，因而物理页面起始地址的高20位可以看做是物理页面的序号。所以，pte_t中的低12位用于页面的状态信息和访问权限。在内核代码并没有在pte_t等结构中定义有关的位段，而是在page.h中另行定义一个用来说明页面保护的结构pgprot_t:

```c
    typedef struct {unsigned long pgport; } pgprot_t;
```
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403c.png "标志位")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403d.png "标志位")

注意这里的PAGE_PROTNONE对应页面表项中的bit7，在intel的手册中说这一项保留不用，所以对MMU不起作用。
在实际使用中，pgprot的数值总是小于0x1000，而pte中的指针部分则总是大于0x1000，将两者合在一起就得到使用用于页面表中的表项。具体的计算是由pgtable.h中定义的宏操作mk_pte完成的：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403e.png "mk_pte")

这里将页面序号左移动12位，再与页面的控制/状态位段相或，就得到了表项的值。这里引用的两个宏操作均定义于include/asm-i386/page.h中：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403f.png "宏操作")

内核中有个全局量mem_map，是一个指针，指向一个page数据结构的数组，每个page数据结构代表着一个物理页面。因此，页面表项的高20位对于软件和MMU硬件有着不同的意义。对于软件，这是个物理页面的序号，将这个序号用作下标就可以从mem_map找到代表这个物理页面的page数据结构。对于硬件，则就是物理页面的起始地址。

还有一个常用的宏操作set_pte(),用来把一个表项的值设置到一个页面表项中，这个宏操作定义于include/asm-i386/pgtable-2level.h中：
```c
   #define set_pte(pteptr, pteval)( *(pteptr) = pteval )
```

在映射的过程中，MMU首先检查的是P标志位，就是上面的PAGE_PRESENT，它指示着所映射的页面是否存在内存中。只有在P标志为1的时候MMU才会完成映射的过程：否则就会因不能完成映射产生一次缺页中断，此时表项中其他内容对MMU就没有任何意义了。除MMU硬件根据页面表项的内容进行页面映射，软件也可以设置或检测页面表项的内容，上面的set_pte()就是用来设置页面表项。内核还未检测页面表项的内容定义了一些工具性的函数或宏操作，其中最重要的有：
```c
   #define pte_none(x) ( !(x).pte_low )
   #define pte_present(x) ( (x).pte_low & (_PAGE_PRESENT | _PAGE_PROTNONE ) )
```

对软件来说，页面表项为0表示尚未为这个表项建立映射，所以还是空白；而如果页面表项不为0，但P标志为0，则表示映射已经建立，但是所映射的物理页面不在内存中。

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403h.png "宏操作")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170403g.png "宏操作")

当然，这些标志位只有在P标志为1时才有意义。
当前所述，当页面表项的P标记位为1时，其高20位为相应物理页面起始地址的高20位，由于物理页面的起始地址必然是与页面边界对齐的，所以低12位一定是0。如果把整个物理内存看成一个物理页面的“数组”，那么高20位就是就是数组的下标，也就是物理页面的序号。相应地，用这个下标，就可以在上述的page结构数组中找到代表目标物理页面的数据结构。代码中为此也定义一个宏操作(include/asm-i386/pgtable.h):
```c
    #define pte_page(x) ( mem_map((unsigned long)(((x).pte_low >> PAGE_SHIFT))))
```

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170404a.png "mem_map_t")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170404b.png "mem_map_t")

内核中用来表示这个数据结构的变量名称常常是page或map。
当页面的内容来自一个文件时，index代表着该页面在文件中的序号；当页面的内容被换出到交换设备上，但还保留着内容作为缓冲时，则index指明页面的去向。结构中各个成分的次序是有讲究的，目的是尽量使得联系紧密的若干成分在执行时被装填入高速缓存的同一缓存线。

系统中的每一个物理页面都有一个page结构（或mem_map_t）。系统在初始化时根据物理内存的大小建立起一个page结构数组mem_map，作为物理页面的“仓库”，里面的每个page数据结构都代表系统的一个物理页面。每个物理页面的page结构在这个数组里的下标就是物理页面的序号。“仓库”里的物理页面划分成ZONE_DMA和ZONE_NORMAL两个管理区(根据系统配置，还可能有第三个管理区ZONE_HIGHMEM，用于物理地址超过1GB的存储空间)。

管理区ZONE_DMA里的页面是专供DMA使用的。为什么DMA使用的页面要单独加以管理呢？首先，DMA使用的页面是磁盘I/O所必需的，如果把仓库里所有物理页面分配光了，那就无法进行页面与盘区的交换了。此外，还有些特殊的原因。在i386CPU中，页式存储管理的硬件支持是在CPU内部实现的，而不像另有些CPU那样由一个单独的MMU提供，所以DMA不经过MMU提供的地址映射。这样，外部设备就要直接提供访问物理页面的地址，可是有些外设在这方面往往有些限制，要求用于DMA的物理地址不能过高。另外一方面，正因为DMA不经过MMU提供的地址映射，当DMA所需的缓冲区超过一个物理页面的大小时，就要求两个页面在物理上连续，因为此时DMA控制器不能依靠在CPU内部的MMU将连续的虚存页面映射到物理上不连续的页面。所以，用于DMA的物理页面是要单独加以管理的。

每个管理区都有一个数据结构，即zone_struct数据结构。在zone_struct数据结构中有一组“空闲区间”队列，为什么是“一组”队列，而不是“一个”队列呢，这也是因为常常需要成“块”地分配在物理空间内连续的多个页面，所以要按块的大小分别加以管理。因此，在管理区数据结构中既要有一个队列来保持一些离散（连续长度为1）的物理页面，还要有一个队列来保持一些连续长度为2的页面块以及连续长度为4,8,16，...，直到2的MAX_ORDER的页面块。常数MAX_ORDER定义为10，也就是是说最大的连续页面块可以达到1024个页面，即4M字节。这两个数据结构以及几个常数定义在include/linux/mmzone.h中：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170404c.png "zone")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170404d.png "zone")
